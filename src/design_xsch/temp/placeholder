
    
    * Calculate differential output for conversion gain measurement
    * let v_out_diff = v(v_out_p) - v(v_out_n)
    * let v_rf_diff = v(v_rf) - v(v_rf_b)
    
    * Extract IF component at 100MHz using FFT
    * linearize v_out_diff v_rf_diff
    * let time_step = 1e-12
    * let sample_freq = 1/time_step
    * let npts = length(v_out_diff)
    * let freq_res = sample_freq/npts
    
    * fft v_out_diff v_rf_diff
    
    * Find frequency bins
    * let if_bin = floor(f_if/freq_res)
    * let rf_bin = floor(f_rf/freq_res)
    
    * Measure conversion gain (power gain from RF to IF)
    * let rf_mag = abs(v_rf_diff[rf_bin])
    * let if_mag = abs(v_out_diff[if_bin])
    * let conversion_gain_db = 20*log10(if_mag/rf_mag)
    * print conversion_gain_db

    * write Gilbert_cell.raw

    * Two-tone test for IIP2 and IIP3 measurement
    * Define time vector
    * let time = (vector(1000) - 1) * 1e-12

    * Reset LO sources for two-tone test
    * alter @voltageLO[VOL] = '1.5 + 0.05*sin(2*pi*2.39e9*time) + 0.05*sin(2*pi*2.41e9*time)'
    * alter @voltageLOb[VOL] = '1.5 - 0.05*sin(2*pi*2.39e9*time) - 0.05*sin(2*pi*2.41e9*time)'
    
    * tran 1p 100n
    
    * Calculate differential output for two-tone analysis
    * let v_out_diff_2tone = v(v_out_p) - v(v_out_n)
    
    * Linearize and perform FFT for intermodulation analysis
    * linearize v_out_diff_2tone
    * let time_step = 1e-12
    * let sample_freq = 1/time_step
    * let npts = length(v_out_diff_2tone)
    * let freq_res = sample_freq/npts
    
    * fft v_out_diff_2tone
    * let freq_axis = vector(npts)
    * let freq_axis = freq_res * vector(npts)
    
    * Find frequency bins for measurements
    * let if_bin = floor(100e6/freq_res)
    * let im2_bin = floor(20e6/freq_res) 
    * let im3_low_bin = floor(80e6/freq_res)  ; 2*2.39-2.41 = 2.37 -> 100M - 20M = 80M at IF
    * let im3_high_bin = floor(120e6/freq_res) ; 2*2.41-2.39 = 2.43 -> 100M + 20M = 120M at IF
    
    * Extract magnitudes at specific frequencies
    * let fund_mag = abs(v_out_diff_2tone[if_bin])
    * let im2_mag = abs(v_out_diff_2tone[im2_bin])
    * let im3_mag = maximum(abs(v_out_diff_2tone[im3_low_bin]), abs(v_out_diff_2tone[im3_high_bin]))
    
    * Calculate IIP2 and IIP3 (simplified calculation)
    * let input_power_dbm = 10*log10(0.05*0.05/50e-3) + 30  ; Input power in dBm (50 ohm)
    * let iip2_dbm = input_power_dbm + (20*log10(fund_mag) - 20*log10(im2_mag))/2
    * let iip3_dbm = input_power_dbm + (20*log10(fund_mag) - 20*log10(im3_mag))*2/3
    
    * print iip2_dbm iip3_dbm

    * write Gilbert_cell.raw

    * Noise analysis for Noise Figure calculation
    * Reset to single tone for noise analysis
    * alter @voltageLO[VOL] = '1.5 + 0.001*sin(2*pi*2.4e9*time)'  ; Small signal for noise
    * alter @voltageLOb[VOL] = '1.5 - 0.001*sin(2*pi*2.4e9*time)'
    
    * noise v(v_out_p,v_out_n) voltageLO dec 10 1e6 1e9
    
    * Calculate Single Sideband Noise Figure
    * NF_SSB = NF_DSB + 3dB (for double sideband to single sideband conversion)
    * setplot noise1
    * let nf_dsb_db = 10*log10(onoise_total^2/inoise_total^2)
    * let nf_ssb_db = nf_dsb_db + 3
    * print nf_ssb_db

    * Summary of measurements
    * echo
    * echo *** GILBERT CELL MIXER PERFORMANCE SUMMARY ***
    * echo Conversion Gain: $&conversion_gain_db dB
    * echo IIP2: $&iip2_dbm dBm  
    * echo IIP3: $&iip3_dbm dBm
    * echo Single Sideband Noise Figure: $&nf_ssb_db dB
    * echo
    
    * write Gilbert_cell.raw
.
